# 工作日志 - Data Formulator 性能与交互优化（Excel 导入 / 灵感缓存）

- **日期**：2025-12-04
- **项目**：Data Formulator（本地中文化版本）
- **主要目标**：
  - 提升数据加载阶段对 Excel 文件（特别是旧版 `.xls`）的兼容性与健壮性。
  - 改善 Encoding Shelf 中探索 Agent 提供“灵感问题”时的交互体验，减少重复调用与等待。
  - 保持前后端构建与运行链路顺畅，确保新特性在本地环境完整可用。

---

## 一、数据加载与 Excel 导入兼容性改造

### 1. 问题背景

- 现象：上传 Excel 文件（如 `SD0501-1450运卷轨道发货查询.xls`）时，前端系统消息提示：
  - `解析 Excel 文件失败：<文件名>。请检查文件格式后重试。`
- 原因分析：
  - 前端 `TableSelectionView` 会把扩展名为 `.xls`、`.xlsx` 的文件统一当作 Excel 处理：
    - 通过 `FileReader.readAsArrayBuffer` 读取二进制。
    - 调用 `loadBinaryDataWrapper(uniqueName, arrayBuffer)` 解析。
  - `src/data/utils.ts` 中的 `loadBinaryDataWrapper` 仅使用 **ExcelJS** 的 `workbook.xlsx.load(arrayBuffer)`，
    - ExcelJS 只支持 `.xlsx`，不支持旧版 `.xls`，导致 `.xls` 文件在解析时抛出异常；
    - 异常在 `loadBinaryDataWrapper` 内被捕获并返回空数组，最终触发前端“解析失败”提示。

### 2. 设计与实现：区分 `.xls` / `.xlsx` 解析路径

#### 2.1 新增依赖

- 在 `package.json` 中增加依赖：
  - 运行时：`"xlsx": "^0.18.5"`
  - 开发时类型声明：`"@types/xlsx": "^0.0.36"`
- 目的：
  - 使用 SheetJS `xlsx` 库在浏览器端解析旧版 `.xls` 文件；
  - 避免改动现有基于 ExcelJS 的 `.xlsx` 解析逻辑。

#### 2.2 `loadBinaryDataWrapper` 改造

- 文件：`src/data/utils.ts`
- 关键改动：
  1. 新增导入：
     - `import * as XLSX from 'xlsx';`
  2. 函数签名扩展：
     - 原：`loadBinaryDataWrapper(title: string, arrayBuffer: ArrayBuffer)`
     - 新：`loadBinaryDataWrapper(title: string, arrayBuffer: ArrayBuffer, fileName?: string)`，
       以 `fileName`/`title` 作为判断扩展名的依据。
  3. 基于扩展名分支处理：
     - 计算 `lowerName = (fileName || title || '').toLowerCase()`。
     - `isXls = lowerName.endsWith('.xls') && !lowerName.endsWith('.xlsx')`。
  4. 对 `.xls` 使用 `xlsx` 解析：
     ```ts
     const workbook = XLSX.read(arrayBuffer, { type: 'array' });

     workbook.SheetNames.forEach((sheetName: string) => {
         const sheet = workbook.Sheets[sheetName];
         if (!sheet) return;

         const jsonData: any[] = XLSX.utils.sheet_to_json(sheet, { defval: null });
         const sheetTable = createTableFromFromObjectArray(`${title}-${sheetName}`, jsonData, true);
         tables.push(sheetTable);
     });
     ```
  5. 对 `.xlsx` 继续沿用 ExcelJS：
     - 通过 `workbook.xlsx.load(arrayBuffer)` 加载；
     - 第一行作为表头，后续行构造 `rowData`，再转换为 `DictTable`，保持原有行为不变。
  6. 统一异常处理：
     - 任一分支解析异常时，打印 `Error processing Excel file` 日志并返回空数组，以维持原有错误提示链路。

#### 2.3 `TableSelectionView` 调用更新

- 文件：`src/views/TableSelectionView.tsx`
- 在处理 Excel 文件的分支中，将 `file.name` 传入 `loadBinaryDataWrapper`：
  ```ts
  let tables = await loadBinaryDataWrapper(uniqueName, arrayBuffer, file.name);
  ```
- 意义：
  - 让解析函数明确知道真实文件名，从而正确区分 `.xls` 与 `.xlsx`，避免将 `.xls` 误走到 ExcelJS 路径。

### 3. 构建与运行验证

- 依赖安装与构建：
  - 解决 `vite` 构建阶段报错：`Rollup failed to resolve import "xlsx" ...`：
    - 通过 `yarn add xlsx` & `yarn add -D @types/xlsx` 安装依赖；
    - 重新执行 `yarn build`，确认构建通过。
- 本地运行：
  - 使用 `./local_server.sh` 启动服务，访问 Data Formulator 页面；
  - 实测：
    - `.xlsx` 文件导入行为与改造前保持一致；
    - `.xls` 文件可直接上传解析为表格，不再出现“解析 Excel 文件失败”的系统提示。

---

## 二、探索 Agent 灵感问题体验与缓存优化

### 1. 灵感获取失败提示排查

- 现象：
  - Encoding Shelf 顶部区域出现系统消息：
    - `(encoding shelf) - Failed to get ideas from the exploration agent. Please try again.`
- 代码路径梳理：
  1. 前端逻辑：`src/views/EncodingShelfCard.tsx` 中 `getIdeasForVisualization`：
     - 构造消息体（包含 `input_tables`、`exploration_thread`、`current_chart` PNG、`agent_exploration_rules` 等）；
     - 调用 `fetch(getUrls().GET_RECOMMENDATION_QUESTIONS, ...)`；
     - 以流式方式读取响应体，将 `data: { ... }` 行解析为 JSON；
     - 任何 HTTP 错误 / 超时 / 流读取异常均会进入 `catch`，进而派发上述错误消息。
  2. 后端路由：`py-src/data_formulator/agent_routes.py` 中 `get_recommendation_questions`：
     - 根据请求中的 `language` 决定是否挂接 SQL 连接；
     - 构造 `InteractiveExploreAgent`，调用其 `run(...)` 以流式产出推荐问题；
     - 任意异常会记日志并返回 `error: {"content": "unable to process recommendation questions request"}`。
- 结论：
  - 该错误提示本身是**统一兜底文案**，并不直接指向特定业务 bug；
  - 今日主要是厘清错误来源与调用链，为后续问题定位和用户提示优化打基础。

### 2. Encoding Shelf 灵感缓存设计与实现

#### 2.1 背景与目标

- 之前的体验：
  - 用户点击一次“获取灵感”，界面展示一批问题；
  - 选择其中一个问题触发派生数据/新图表后，若想再尝试另一个灵感，经常需要再次点击“获取灵感”，重复等待 LLM 响应。
- 目标：
  - 在**同一张图（同一 `chartId`）**下，对从 `/api/agent/get-recommendation-questions` 拿到的灵感问题做前端缓存；
  - 允许用户在一批灵感中多次选择和尝试，而不是频繁重复调用后端；
  - 仅在用户主动选择“换一批灵感”时才重新触发请求。

#### 2.2 状态建模与缓存结构

- 文件：`src/views/EncodingShelfCard.tsx`
- 新增类型与全局缓存：
  ```ts
  type ChartIdea = {
      text: string;
      goal: string;
      difficulty: 'easy' | 'medium' | 'hard';
      tag?: string;
  };

  type ChartIdeaState = {
      ideas: ChartIdea[];
      thinkingBuffer: string;
      isLoading: boolean;
  };

  const globalChartIdeaState: Record<string, ChartIdeaState> = {};
  ```
- 组件内部 `chartState` 初始值：
  ```ts
  const [chartState, setChartState] = useState<Record<string, ChartIdeaState>>(() => ({
      ...globalChartIdeaState
  }));
  ```
- 派生当前图表的灵感状态：
  ```ts
  const currentState = chartState[chartId] || { ideas: [], thinkingBuffer: "", isLoading: false };
  const currentChartIdeas = currentState.ideas;
  const thinkingBuffer = currentState.thinkingBuffer;
  const isLoadingIdeas = currentState.isLoading;
  ```

#### 2.3 状态更新与全局缓存同步

- 为当前 `chartId` 封装三个更新函数，并在内部同步更新 `globalChartIdeaState`：
  ```ts
  const setIdeas = (ideas: ChartIdea[]) => {
      setChartState(prev => {
          const prevForChart: ChartIdeaState = prev[chartId] || {
              ideas: [],
              thinkingBuffer: "",
              isLoading: false
          };
          const nextForChart: ChartIdeaState = { ...prevForChart, ideas };
          const next = { ...prev, [chartId]: nextForChart };
          globalChartIdeaState[chartId] = nextForChart;
          return next;
      });
  };

  const setThinkingBuffer = (thinkingBuffer: string) => { /* 同步更新 globalChartIdeaState */ };

  const setIsLoadingIdeas = (isLoading: boolean) => { /* 同步更新 globalChartIdeaState */ };
  ```
- 这样设计的效果：
  - 同一页面会话内，只要未刷新浏览器，某个 `chartId` 曾经获取过的灵感会保留在 `globalChartIdeaState` 中；
  - 即使 Encoding Shelf 组件因为 UI 切换被卸载/重新挂载，重新挂载时会从全局缓存恢复该图的灵感列表。

#### 2.4 交互逻辑调整

- 顶部模式切换头 `ModeToggleHeader` 的行为：
  - 若 `currentChartIdeas.length > 0`：
    - 点击灯泡标题只会切换到“灵感模式”，不触发新的网络请求；
  - 若当前还没有灵感：
    - 首次点击会调用 `getIdeasForVisualization()`，向 `/api/agent/get-recommendation-questions` 发起请求。
- 灵感区域按钮：
  - 在 ideate 模式下，按钮文案区分：
    - 首轮：`Get Ideas?`（无缓存时）
    - 有缓存但想换新一批时：`Different ideas?`，只有用户点击该按钮才再次向后端请求。
- 效果：
  - 用户可以在同一批推荐问题中，连续多次点击不同的 `IdeaChip` 进行尝试；
  - 只有确实需要“换一批”时才重新请求，减少不必要的 LLM 调用与等待时间。

---

## 三、构建与运行链路验证（针对今日改动）

- 前端：
  - 完成对 `xlsx` 依赖引入与 TS 类型声明的修正；
  - 使用 `yarn build` 验证 Vite 构建流程，解决因未安装 `xlsx` 导致的 Rollup 解析错误；
  - 通过 `./local_server.sh` 启动本地服务并多次刷新页面，确认静态资源加载正常，Encoding Shelf 功能可用。
- 后端：
  - 多次调用 `/api/agent/get-recommendation-questions`、`/api/agent/derive-data`、`/api/agent/process-data-on-load` 等接口，结合终端日志确认 200 返回与流式输出正常；
  - 未对后端 Agent 接口签名做修改，仅在前端侧增强兼容性与交互逻辑。

---

## 四、后续可选工作与改进方向

1. **灵感缓存粒度进一步优化**
   - 目前缓存键为 `chartId`，适合单图多次尝试的场景；
   - 后续可考虑：
     - 以“根表 + 过滤条件”作为 key，在同一数据上下文下的多个图表之间复用灵感结果；
     - 为不同模式（交互模式 / agent 模式）保留独立的灵感列表。

2. **探索 Agent 错误提示友好性**
   - 在前端区分：
     - HTTP 层面失败（网络 / 500）与
     - Agent 内部返回的 `error: {...}` 语义错误；
   - 针对性给出更精确的中文提示，便于业务同事理解问题来源（网络、权限、模型不可用等）。

3. **Excel 导入边界测试与性能评估**
   - 针对不同大小、不同工作表数量的 `.xls` / `.xlsx` 文件，补充简单性能与正确性验证；
   - 如有必要，可针对极大文件增加行/列采样逻辑，避免前端内存压力过大。

---

## 五、今日工作小结

- 完成对 Excel 导入链路的“老格式 `.xls` 支持”，彻底解决了此前上传旧版 Excel 报“解析失败”的问题；
- 梳理并实现了 Encoding Shelf 中探索 Agent 灵感问题的前端缓存机制，大幅减少重复请求，提升交互流畅度；
- 通过 `yarn build` 与本地服务启动，对上述改动做了端到端验证，当前版本可稳定支撑日常使用与后续性能回归测试。
